# å‰ç«¯è¯·æ±‚ç³»ç»Ÿ - å®Œæ•´ä½¿ç”¨æŒ‡å—

> ğŸ¨ **æ–‡æ¡£ä½ç½®**: `doc/å‰ç«¯è¯·æ±‚.md`
> 
> **å…³è”æ–‡ä»¶**:
> - `frontend/src/service/request.ts` - è¯·æ±‚å°è£…
> - `frontend/src/service/api/*.ts` - API å®šä¹‰
> - `frontend/src/typings/*.d.ts` - ç±»å‹å®šä¹‰

---

## ğŸ“‹ ç›®å½•

1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [è¯·æ±‚å°è£…](#è¯·æ±‚å°è£…)
3. [API å®šä¹‰](#api-å®šä¹‰)
4. [ç±»å‹å®šä¹‰](#ç±»å‹å®šä¹‰)
5. [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
6. [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
7. [è¯·æ±‚æ‹¦æˆª](#è¯·æ±‚æ‹¦æˆª)
8. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯è¯·æ±‚æ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚   Component                                                      â”‚
â”‚       â”‚                                                          â”‚
â”‚       â–¼                                                          â”‚
â”‚   API Function (src/service/api/*.ts)                           â”‚
â”‚       â”‚                                                          â”‚
â”‚       â–¼                                                          â”‚
â”‚   Request Instance (Alova)                                       â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â”€â–º Request Interceptor â”€â”€â–º æ·»åŠ  Token                   â”‚
â”‚       â”‚                                                          â”‚
â”‚       â”œâ”€â”€â–º Response Interceptor â”€â”€â–º ç»Ÿä¸€é”™è¯¯å¤„ç†                â”‚
â”‚       â”‚                                                          â”‚
â”‚       â””â”€â”€â–º HTTP Request â”€â”€â–º Backend API                         â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## è¯·æ±‚å°è£…

### Alova é…ç½®

**æ–‡ä»¶**: `frontend/src/service/request.ts`

```typescript
import { createAlova } from 'alova'
import GlobalFetch from 'alova/GlobalFetch'
import VueHook from 'alova/vue'
import { useAuthStore } from '@/store'
import { router } from '@/router'

// åˆ›å»º Alova å®ä¾‹
export const request = createAlova({
  baseURL: '/api',
  statesHook: VueHook,
  requestAdapter: GlobalFetch(),
  
  // è¯·æ±‚æ‹¦æˆªå™¨
  beforeRequest(method) {
    // æ·»åŠ  Token
    const authStore = useAuthStore()
    if (authStore.token) {
      method.config.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    // æ·»åŠ  Content-Type
    if (!method.config.headers['Content-Type']) {
      method.config.headers['Content-Type'] = 'application/json'
    }
  },
  
  // å“åº”æ‹¦æˆªå™¨
  responded: {
    // æˆåŠŸå“åº”
    onSuccess: async (response, method) => {
      const data = await response.json()
      
      // ç»Ÿä¸€é”™è¯¯å¤„ç†
      if (data.code !== 200) {
        // å¤„ç†ç‰¹å®šé”™è¯¯ç 
        if (data.code === 401) {
          // Token è¿‡æœŸï¼Œè·³è½¬ç™»å½•
          const authStore = useAuthStore()
          authStore.logout()
          router.push('/login')
          throw new Error(data.message || 'ç™»å½•å·²è¿‡æœŸ')
        }
        
        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        window.$message?.error(data.message || 'è¯·æ±‚å¤±è´¥')
        throw new Error(data.message)
      }
      
      return data
    },
    
    // é”™è¯¯å“åº”
    onError: async (error, method) => {
      window.$message?.error('ç½‘ç»œè¯·æ±‚å¤±è´¥')
      throw error
    },
    
    // è¯·æ±‚å®Œæˆï¼ˆæ— è®ºæˆåŠŸå¤±è´¥ï¼‰
    onComplete: async (method) => {
      // å¯ä»¥åœ¨è¿™é‡Œå…³é—­ loading
    }
  }
})
```

### ç±»å‹å®šä¹‰

**æ–‡ä»¶**: `frontend/src/typings/request.d.ts`

```typescript
declare namespace Service {
  // é€šç”¨å“åº”ç»“æ„
  interface ResponseResult<T = unknown> {
    code: number
    message: string
    data: T
  }
  
  // åˆ†é¡µæ•°æ®
  interface PaginatedData<T> {
    list: T[]
    total: number
    page: number
    pageSize: number
  }
  
  // ç™»å½•å“åº”
  interface LoginResult {
    id: number
    userName: string
    email: string
    role: string[]
    accessToken: string
    refreshToken: string
  }
}
```

---

## API å®šä¹‰

### è®¤è¯ç›¸å…³ API

**æ–‡ä»¶**: `frontend/src/service/api/login.ts`

```typescript
import { request } from '../request'

// ç™»å½•
export function fetchLogin(data: { username: string; password: string }) {
  return request.Post<Service.ResponseResult<Service.LoginResult>>(
    '/api/login',
    data
  )
}

// æ³¨å†Œ
export function fetchRegister(data: {
  username: string
  password: string
  email: string
  code: string
}) {
  return request.Post<Service.ResponseResult<null>>('/api/register', data)
}

// å‘é€æ³¨å†ŒéªŒè¯ç 
export function fetchSendRegisterCode(data: { email: string; lang: string }) {
  return request.Post<Service.ResponseResult<null>>(
    '/api/v1/user/send-register-code',
    data
  )
}

// å‘é€é‡ç½®å¯†ç é‚®ä»¶
export function fetchSendResetEmail(data: { email: string; lang: string }) {
  return request.Post<Service.ResponseResult<null>>(
    '/api/v1/user/resetpasswordtoemail',
    data
  )
}

// ç¡®è®¤é‡ç½®å¯†ç 
export function fetchResetPasswordConfirm(data: {
  email: string
  code: string
  newPassword: string
}) {
  return request.Post<Service.ResponseResult<null>>(
    '/api/v1/user/reset-password',
    data
  )
}

// åˆ·æ–° Token
export function fetchUpdateToken(data: { refreshToken: string }) {
  return request.Post<
    Service.ResponseResult<{ accessToken: string; refreshToken: string }>
  >('/api/updateToken', data)
}

// è·å–ç”¨æˆ·è·¯ç”±
export function fetchGetUserRoutes() {
  return request.Get<Service.ResponseResult<AppRoute.Route[]>>(
    '/api/getUserRoutes'
  )
}
```

### ç”¨æˆ·ç›¸å…³ API

**æ–‡ä»¶**: `frontend/src/service/api/user.ts`

```typescript
import { request } from '../request'

// è·å–ç”¨æˆ·ä¿¡æ¯
export function fetchGetUserProfile() {
  return request.Get<Service.ResponseResult<Entity.User>>('/api/profile')
}

// æ›´æ–°ç”¨æˆ·ä¿¡æ¯
export function fetchUpdateUserProfile(data: Partial<Entity.User>) {
  return request.Put<Service.ResponseResult<Entity.User>>(
    '/api/profile',
    data
  )
}

// ä¸Šä¼ å¤´åƒ
export function fetchUploadAvatar(file: File) {
  const formData = new FormData()
  formData.append('file', file)
  
  return request.Post<Service.ResponseResult<{ url: string }>>(
    '/api/upload/avatar',
    formData,
    {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    }
  )
}
```

### ç³»ç»Ÿç›¸å…³ API

**æ–‡ä»¶**: `frontend/src/service/api/system.ts`

```typescript
import { request } from '../request'

// è·å–ç”¨æˆ·åˆ—è¡¨
export function fetchGetUserList(params: { page: number; pageSize: number }) {
  return request.Get<Service.ResponseResult<Service.PaginatedData<Entity.User>>>(
    '/api/userPage',
    { params }
  )
}

// è·å–è§’è‰²åˆ—è¡¨
export function fetchGetRoleList() {
  return request.Get<Service.ResponseResult<Entity.Role[]>>('/api/role/list')
}

// è·å–å­—å…¸åˆ—è¡¨
export function fetchGetDictList() {
  return request.Get<Service.ResponseResult<Entity.Dict[]>>('/api/dict/list')
}
```

---

## ç±»å‹å®šä¹‰

### å®ä½“ç±»å‹

**æ–‡ä»¶**: `frontend/src/typings/entities/user.d.ts`

```typescript
declare namespace Entity {
  interface User {
    id: number
    username: string
    nickname?: string
    email?: string
    mobile?: string
    avatar?: string
    backGround?: string
    gender: number
    birthday?: string
    role: string
    status: number
    lastLoginTime?: string
    lastLoginIP?: string
    createdAt: string
    updatedAt: string
  }
  
  interface Role {
    id: number
    name: string
    code: string
    description?: string
    status: number
  }
  
  interface Dict {
    id: number
    type: string
    code: string
    value: string
    sort: number
    status: number
  }
}
```

### è·¯ç”±ç±»å‹

**æ–‡ä»¶**: `frontend/src/typings/app-route.d.ts`

```typescript
declare namespace AppRoute {
  interface Route {
    name: string
    path: string
    component?: string
    redirect?: string
    meta?: {
      title?: string
      icon?: string
      requiresAuth?: boolean
      roles?: string[]
      keepAlive?: boolean
      hideInMenu?: boolean
    }
    children?: Route[]
  }
}
```

---

## ä½¿ç”¨ç¤ºä¾‹

### åœ¨ç»„ä»¶ä¸­ä½¿ç”¨

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { fetchGetUserProfile, fetchUpdateUserProfile } from '@/service'

const userInfo = ref<Entity.User | null>(null)
const loading = ref(false)

// è·å–ç”¨æˆ·ä¿¡æ¯
async function loadUserProfile() {
  try {
    loading.value = true
    const res = await fetchGetUserProfile()
    userInfo.value = res.data
  } catch (error) {
    console.error('Failed to load profile:', error)
  } finally {
    loading.value = false
  }
}

// æ›´æ–°ç”¨æˆ·ä¿¡æ¯
async function handleUpdate() {
  if (!userInfo.value) return
  
  try {
    await fetchUpdateUserProfile({
      nickname: userInfo.value.nickname,
      email: userInfo.value.email
    })
    window.$message?.success('æ›´æ–°æˆåŠŸ')
  } catch (error) {
    console.error('Failed to update:', error)
  }
}

onMounted(() => {
  loadUserProfile()
})
</script>
```

### åœ¨ Store ä¸­ä½¿ç”¨

```typescript
// src/store/auth.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { fetchLogin, fetchGetUserRoutes } from '@/service'

export const useAuthStore = defineStore('auth', () => {
  // State
  const token = ref<string>('')
  const refreshToken = ref<string>('')
  const userInfo = ref<Entity.User | null>(null)
  const userRoutes = ref<AppRoute.Route[]>([])
  
  // Getters
  const isLoggedIn = computed(() => !!token.value)
  const isAdmin = computed(() => userInfo.value?.role === 'admin')
  
  // Actions
  async function login(credentials: { username: string; password: string }) {
    const res = await fetchLogin(credentials)
    
    token.value = res.data.accessToken
    refreshToken.value = res.data.refreshToken
    userInfo.value = {
      id: res.data.id,
      username: res.data.userName,
      email: res.data.email,
      role: res.data.role[0]
    } as Entity.User
    
    // è·å–ç”¨æˆ·è·¯ç”±
    await loadUserRoutes()
    
    return res.data
  }
  
  async function loadUserRoutes() {
    const res = await fetchGetUserRoutes()
    userRoutes.value = res.data
    return res.data
  }
  
  function logout() {
    token.value = ''
    refreshToken.value = ''
    userInfo.value = null
    userRoutes.value = []
  }
  
  return {
    token,
    refreshToken,
    userInfo,
    userRoutes,
    isLoggedIn,
    isAdmin,
    login,
    logout,
    loadUserRoutes
  }
})
```

### ä½¿ç”¨ useRequest Hook

```vue
<script setup lang="ts">
import { useRequest } from 'alova'
import { fetchGetUserProfile, fetchUpdateUserProfile } from '@/service'

// è‡ªåŠ¨å¤„ç† loading å’Œ error
const { data: userInfo, loading, send: refresh } = useRequest(fetchGetUserProfile)

// æ‰‹åŠ¨è§¦å‘è¯·æ±‚
const { send: updateProfile, loading: updating } = useRequest(
  (data) => fetchUpdateUserProfile(data),
  { immediate: false }
)

async function handleSave() {
  await updateProfile(userInfo.value)
  window.$message?.success('ä¿å­˜æˆåŠŸ')
  refresh()
}
</script>
```

---

## é”™è¯¯å¤„ç†

### å…¨å±€é”™è¯¯å¤„ç†

```typescript
// src/service/request.ts
export const request = createAlova({
  // ... å…¶ä»–é…ç½®
  
  responded: {
    onSuccess: async (response) => {
      const data = await response.json()
      
      if (data.code !== 200) {
        // æ ¹æ®é”™è¯¯ç å¤„ç†
        switch (data.code) {
          case 400:
            window.$message?.error(data.message || 'è¯·æ±‚å‚æ•°é”™è¯¯')
            break
          case 401:
            window.$message?.error('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•')
            handleTokenExpired()
            break
          case 403:
            window.$message?.error('æ²¡æœ‰æƒé™æ‰§è¡Œæ­¤æ“ä½œ')
            break
          case 404:
            window.$message?.error('è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨')
            break
          case 500:
            window.$message?.error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯')
            break
          default:
            window.$message?.error(data.message || 'è¯·æ±‚å¤±è´¥')
        }
        
        throw new Error(data.message)
      }
      
      return data
    },
    
    onError: async (error) => {
      if (error.name === 'TypeError' && error.message === 'Failed to fetch') {
        window.$message?.error('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ')
      } else {
        window.$message?.error('ç½‘ç»œè¯·æ±‚å¤±è´¥')
      }
      throw error
    }
  }
})

// Token è¿‡æœŸå¤„ç†
function handleTokenExpired() {
  const authStore = useAuthStore()
  authStore.logout()
  router.push('/login')
}
```

### å±€éƒ¨é”™è¯¯å¤„ç†

```typescript
async function loadData() {
  try {
    const res = await fetchSomeApi()
    return res.data
  } catch (error) {
    // å±€éƒ¨å¤„ç†ç‰¹å®šé”™è¯¯
    if (error.message === 'ç‰¹å®šé”™è¯¯') {
      // ç‰¹æ®Šå¤„ç†
      return defaultValue
    }
    // å…¶ä»–é”™è¯¯å‘ä¸ŠæŠ›å‡º
    throw error
  }
}
```

---

## è¯·æ±‚æ‹¦æˆª

### æ·»åŠ  Loading

```typescript
// è¯·æ±‚è®¡æ•°å™¨
let requestCount = 0

function showLoading() {
  if (requestCount === 0) {
    window.$loading?.start()
  }
  requestCount++
}

function hideLoading() {
  requestCount--
  if (requestCount <= 0) {
    requestCount = 0
    window.$loading?.finish()
  }
}

export const request = createAlova({
  beforeRequest(method) {
    showLoading()
    // ... å…¶ä»–å¤„ç†
  },
  
  responded: {
    onSuccess: async (response, method) => {
      hideLoading()
      // ... å…¶ä»–å¤„ç†
    },
    onError: async (error, method) => {
      hideLoading()
      // ... å…¶ä»–å¤„ç†
    }
  }
})
```

### Token åˆ·æ–°æœºåˆ¶

```typescript
let isRefreshing = false
let refreshSubscribers: Array<(token: string) => void> = []

function subscribeTokenRefresh(callback: (token: string) => void) {
  refreshSubscribers.push(callback)
}

function onTokenRefreshed(newToken: string) {
  refreshSubscribers.forEach(callback => callback(newToken))
  refreshSubscribers = []
}

async function refreshToken() {
  const authStore = useAuthStore()
  
  try {
    const res = await fetchUpdateToken({ refreshToken: authStore.refreshToken })
    authStore.token = res.data.accessToken
    authStore.refreshToken = res.data.refreshToken
    return res.data.accessToken
  } catch (error) {
    authStore.logout()
    router.push('/login')
    throw error
  }
}

export const request = createAlova({
  responded: {
    onSuccess: async (response, method) => {
      const data = await response.json()
      
      if (data.code === 401) {
        // Token è¿‡æœŸï¼Œå°è¯•åˆ·æ–°
        if (!isRefreshing) {
          isRefreshing = true
          
          try {
            const newToken = await refreshToken()
            onTokenRefreshed(newToken)
            isRefreshing = false
            
            // é‡è¯•åŸè¯·æ±‚
            method.config.headers.Authorization = `Bearer ${newToken}`
            return method.send()
          } catch (error) {
            isRefreshing = false
            throw error
          }
        } else {
          // ç­‰å¾…åˆ·æ–°å®Œæˆ
          return new Promise((resolve) => {
            subscribeTokenRefresh((newToken) => {
              method.config.headers.Authorization = `Bearer ${newToken}`
              resolve(method.send())
            })
          })
        }
      }
      
      return data
    }
  }
})
```

---

## æœ€ä½³å®è·µ

### 1. API å‡½æ•°å‘½å

```typescript
// âœ… æ¨èï¼šä½¿ç”¨ fetch å‰ç¼€ + åŠ¨è¯ + èµ„æºå
fetchGetUserList
fetchCreateUser
fetchUpdateUser
fetchDeleteUser
fetchUploadAvatar

// âŒ ä¸æ¨è
getUserList      // æ²¡æœ‰ fetch å‰ç¼€
userList         // ä¸æ¸…æ™°æ˜¯è¯·æ±‚è¿˜æ˜¯æ•°æ®
requestUserList  // è¿‡äºå†—ä½™
```

### 2. ç±»å‹å®šä¹‰

```typescript
// âœ… æ¨èï¼šå®Œæ•´çš„ç±»å‹å®šä¹‰
interface LoginRequest {
  username: string
  password: string
}

interface LoginResponse {
  accessToken: string
  refreshToken: string
  user: Entity.User
}

export function fetchLogin(data: LoginRequest) {
  return request.Post<Service.ResponseResult<LoginResponse>>('/api/login', data)
}

// âŒ ä¸æ¨è
export function fetchLogin(data: any) {
  return request.Post('/api/login', data)
}
```

### 3. é”™è¯¯å¤„ç†

```typescript
// âœ… æ¨èï¼šåœ¨åˆé€‚å±‚çº§å¤„ç†é”™è¯¯
// å…¨å±€ï¼šç»Ÿä¸€é”™è¯¯å“åº”æ ¼å¼
// Storeï¼šä¸šåŠ¡é”™è¯¯å¤„ç†
// ç»„ä»¶ï¼šUI é”™è¯¯åé¦ˆ

async function handleSubmit() {
  try {
    await submitForm()
    message.success('æäº¤æˆåŠŸ')
    router.push('/success')
  } catch (error) {
    // åªå¤„ç†éœ€è¦ç‰¹æ®Šåé¦ˆçš„é”™è¯¯
    if (error.code === 'VALIDATION_ERROR') {
      showFieldErrors(error.fields)
    }
    // å…¶ä»–é”™è¯¯å·²å…¨å±€å¤„ç†
  }
}
```

### 4. è¯·æ±‚å–æ¶ˆ

```typescript
import { useRequest } from 'alova'

// ç»„ä»¶å¸è½½æ—¶è‡ªåŠ¨å–æ¶ˆ
const { data, abort } = useRequest(fetchGetUserList, {
  abortLast: true  // è‡ªåŠ¨å–æ¶ˆä¸Šä¸€æ¬¡çš„è¯·æ±‚
})

// æ‰‹åŠ¨å–æ¶ˆ
function handleCancel() {
  abort()
}
```

---

## API å‚è€ƒ

### request.ts

| å¯¼å‡º | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| request | `Alova` | Alova å®ä¾‹ |

### api/*.ts

| å‡½æ•° | ç­¾å | è¯´æ˜ |
|------|------|------|
| fetchLogin | `(data: LoginRequest) => Promise<ResponseResult<LoginResult>>` | ç™»å½• |
| fetchRegister | `(data: RegisterRequest) => Promise<ResponseResult<null>>` | æ³¨å†Œ |
| fetchSendRegisterCode | `(data: {email, lang}) => Promise<ResponseResult<null>>` | å‘é€éªŒè¯ç  |
| fetchSendResetEmail | `(data: {email, lang}) => Promise<ResponseResult<null>>` | å‘é€é‡ç½®é‚®ä»¶ |
| fetchResetPasswordConfirm | `(data: ResetPasswordRequest) => Promise<ResponseResult<null>>` | ç¡®è®¤é‡ç½®å¯†ç  |
| fetchUpdateToken | `(data: {refreshToken}) => Promise<ResponseResult<TokenResult>>` | åˆ·æ–° Token |
| fetchGetUserRoutes | `() => Promise<ResponseResult<Route[]>>` | è·å–ç”¨æˆ·è·¯ç”± |

---

> ğŸ“ **æœ€åæ›´æ–°**: 2026-02-04
> 
> å¦‚æœ‰ç–‘é—®ï¼Œè¯·å‚è€ƒ `frontend/src/service/*.ts` æºä»£ç ã€‚
